/*************************************************************
    Практическое занятие №2. Побитовые операторы.
                            Директивы препроцессора.
                            Указатели.
*************************************************************/
#include <stdio.h>
#include <math.h>

void toBinary(int num) { 
    for (int i = 31; i >= 0; i--) {
        putchar((num >> i) & 1 ? '1' : '0');
    }
    putchar('\n');
}

void toBinaryShort(short num) {
    for (short i = sizeof(short) * 8 - 1; i >= 0; i--) {
        putchar((num >> i) & 1 ? '1' : '0');
    }
    putchar('\n');
}

int main()
{
    // Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
    // 1.1
    {
        int y = 9; // задайте значение y явно или через scanf

        // С помощью побитовых операторов и операторов сдвига выведите значение "y"
        // в консоль в двоичном виде, например:
        // если y==9, то
        //  а) 0 0 0 0 ...   0 0 1 0 0 1 (количество двоичных цифр зависит от платформы)
        for (int i = 31; i >= 0; i--) {
            putchar((y >> i) & 1 ? '1' : '0');
        } 
        putchar('\n');
        // б) пропустите незначащие нули -  1 0 0 1
        y = 9;
        int flag = 0;
        for (int i = 31; i >= 0; i--) {
            if ((y >> i) & 1) {
                flag = 1;
            }
            if (flag) {
                putchar((y >> i) & 1 ? '1' : '0');
            }
        }
        putchar('\n');
    }
    // 1.2
    {
        unsigned int y = 1325428482U;

        //"Сдвиньте" все единицы переменной вправо, например:
        // было:   0100 1111 0000 0000 0110 1111 0000 0010
        toBinary(y);
    // стало:  0000 0000 0000 0000 0000 1111 1111 1111
    // Реализовать задачу посредством одного цикла
    unsigned int result = 0;
    int cnt = 0;
    for(int i = (sizeof(int) * 8) - 1; i >= 0; i--){
        if((y >> i) & 1){
            //result = result + (1 << cnt);
            cnt++;
        }
    }

    //for(int i = 0; i <= cnt; ++i) {
    //    result = result + (1 << i);
    //}

    for (int i = 31; i >= 0; i--) {
        putchar((result >> i) & 1 ? '1' : '0');
    }
    
    putchar('\n');
    putchar('\n');
}
    
    // 1.3 Какие операции следует применить к заданному ниже операнду sNum для
    // того, чтобы переменная sRes приняла требуемое значение?
    // Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
    // использовать один оператор (и при необходимости маску)
    // Замечание 2: посредством оператора xor (подобрав соответствующую маску)
    // можно получить любое значение => этот оператор предполагается использовать
    // в том случае, когда все остальные уже "не спасают"
    {
        short sNum = 0x8008;
        short sRes;

        //toBinary(sNum);
        // 0x7ff7
        sRes = ~sNum;

        // 0x8ff8
        sRes = sNum | 0x0FF0;
        //toBinary(sRes);
        //toBinary(0x0FF0);

        // 0x0008
        sRes = sNum & 0x0008;
        //toBinary(sRes);

        // 0x7f08
        sRes = sNum ^ 0xFF00;
        //toBinary(sRes);

        // 0xf001
        sRes = sNum >> 3;
        //toBinaryShort(sRes);
        //toBinaryShort(0xf001);
        
        // 0x0010
        sRes = sNum << 1;
        //toBinaryShort(sRes);
        //toBinaryShort(0x0010);
    }

    // ********************************************************
    // Задание 2. Директивы препроцессора

    // 2.1. В заголовочном файле <math.h> определены часто используемые математические
    // константы, например M_PI. Воспользуйтесь этой константой для
    // вычисления длины окружности
    float pi = M_PI;

    // 2.2.Макросы с параметрами.
    // 2.2.1 Напишите свою макроподстановку LENGTH которая вычисляет длину окружности.
    //  протестируйте написанный макрос для следующих ситуаций:
#define LENGTH(x) (2 * (x) * pi)
    {
        float l1 = LENGTH(1 + 2); // должно быть 18.8495...
        float l2 = (1 / LENGTH(2)); // должно быть 0.07957...
    }

    // 2.2.2 определите макрос MAX(A, B)  для вычисления большего
    // значения из двух.
#define MAX(A, B) ((A) > (B) ? A : B) //макрос встает вместо тех значений, где обозначен
    
    int i = 10, j = 12, k;
    k = MAX(i, j);
    k = MAX(j, i) * 2;
    k = MAX(j, i+3);
    MAX(1 > 0, -1 > -2);//Даже при такой записи мы сравниваем 1 и 0, а не числа помещенные между операторами сравнения
                        //в качестве аргументов
                        //Даже в случае одинаковых чисел, макрос выведет верный ответ
    

    // 2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
    // двух объектов типа int в памяти местами. Проверьте для приведенного
    // фрагмента. Подумайте, что будет делать макроподстановка, если
    // переставляемые значения разного типа???

#define EXCHANGE(X, Y) { int temp = X; X = Y; Y = temp; }

        int x1=1, y1=-1;
        EXCHANGE(x1,y1);

        int x2=100;
        double y2= 1.14124;
        EXCHANGE(x2,y2);

    //2.3. Директивы условной трансляции
    //Выполняя следующий фрагмент, посмотрите, какое
    //значение принимает переменная iNN. Что нужно сделать
    //для того, чтобы результат был равен 0? 1? 2?
#define NNN (555)
#define MMM (555)
    //В зависимости от объявленных макросов будут выполняться разные логические операции
int iNN;
#if defined NNN && defined MMM
    iNN = 0;
#elif defined MMM
    iNN = 1;
#elif defined NNN
    iNN = 2;

#else
    iNN = -1;
#endif


    // ********************************************************
    // Задание 3. Заголовочные файлы. Директива #include
    // 3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
    // В каждом заголовочном файле объявите перечисление с одинаковыми именами
    // констант, но сопоставьте именованным константам разные значения, например:
    // 1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
    // С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
    // констант из 1.h, а в RELEASE-версии значениями констант из 2.h

//#define DEBUG
#ifdef DEBUG
#include "1.h"
#else
#include "2.h"
#endif

    enum myEnum test = My1;

    // ********************************************************
    // Задание 4. Указатели
    // Объявите объекты разных типов и проинициализируйте их.
    // Объявите указатели соответствующих типов и проинициализируйте их
    // адресами заданных объектов.
    // Выполняя задание, с помощью отладчика посмотрите, какие значения
    // будут присвоены переменным-указателям и на что эти указатели
    // "указывают"
    int firstTest = 42;
    double secondTest = 42.42;

    int* pf = &firstTest; //0x000000016fdfefac
    double* ps = &secondTest; //0x000000016fdfefa0

    return 0;
}
