#include "functions.h"

// Задание 1 (творческое). swap
// Напишите функцию swap(int *i, int *j), которая меняет значения двух ячеек местами.
// Напишите как можно больше тестов для этой функции (не меньше 10)
// На звёздочку: используйте фреймворк наподобие MinUnit https://github.com/siu/minunit
void swap(int *i, int *j) {
    int temp = *i;
    *i = *j;
    *j = temp;
}

// Задание 2. Указатели на массивы в качестве аргументов.
// Напишите два варианта функции поиска минимального элемента
// 2a. во встроенном двухмерном массиве
// 2b. в динамическом двухмерном массиве (обе размерности вычисляются)
int findMin(int ar[][SIZE_1M], int rows, int cols) { //Массив с изначально заданным размером
    int min = ar[0][0];
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (ar[i][j] < min) min = ar[i][j];
        }
    }
    return min;
}

int findMinDynamic(int **ar, int rows, int cols) { //Размерность массива изначально не задана
    int min = ar[0][0];
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (ar[i][j] < min) min = ar[i][j];
        }
    }
    return min;
}

// Задание 3. Напишите функцию сравнения двух строк - myStrCmp():
// Функция должна принимать два указателя на сравниваемые
// строки (возможно, понадобится сказать компилятору, что функция
// не имеет права модифицировать содержимое строк)
// Функция должна возвращать отрицательное значение, если
// первая строка лексиграфически меньше второй, 0 - если они равны
// и положительное значение, если первая строка больше второй.
// Вспомните, что признаком конца строки является нулевой байт.
int myStrCmp(const char *s1, const char *s2) {
    while (*s1 && *s2) {
        if (*s1 != *s2) return *s1 - *s2;
        s1++;
        s2++;
    }
    return *s1 - *s2;
}

// Задание 4. Создайте одномерный динамический массив, заполните его значениями.
// Напишите функцию, которая добавляет в массив новое значение только при условии,
// что такого значения в массиве еще нет. Подсказка: при этом размер
// массива должен увеличиться!
// Для проверки напишите функцию, которая выводит значения всех элементов на экран
void printArray(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int addUnique(int **arr, int *size, int value) {
    for (int i = 0; i < *size; i++) {
        if ((*arr)[i] == value) return 0; // уже существует, сворачиваемся
    }
    *arr = realloc(*arr, (*size + 1) * sizeof(int));
    if (*arr == NULL) return -1; // проверяем, выделилась ли память: нет - ошибка
    (*arr)[*size] = value;
    (*size)++;
    return 1; // успех
}

// Задание 5. Рекурсивные функции.
// 5a. Напишите рекурсивную функцию вычисления суммы первых N натуральных чисел
// 5б. Напишите рекурсивную функцию для вычисления N-го числа Фибоначчи
int toSum(int n) {
    if (n <= 0) return 0;
    return n + toSum(n - 1);
}

int findFibonacci(int n) {
    if (n <= 1) return n;
    return findFibonacci(n - 1) + findFibonacci(n - 2); //нахождение Фибоначчи с экспоненциальной алг скоростью
}

// Задание 6а. Функции с переменным числом параметров.
// Напишите функцию varArgs, не использующую макросы,
// которая принимает переменное число аргументов (см. подсказку внизу кода задания)
// типа int и выводит на печать число принятых параметров и их значения.
// Признаком конца списка параметров является нулевое значение.
void varArgs(int arg1, ...) {
    int nArgs = 0;
    int *ptr = &arg1;
    while (*ptr != 0) {
        printf("%d ", *ptr);
        ptr++;
        nArgs++;
    }
    printf("\nКоличество принятых аргументов: %d\n", nArgs);
}

void updatedVarArgs(int arg1, ...) {
    va_list args;
    va_start(args, arg1);
    int nArgs = 0;
    int val = arg1;
    while (val != 0) {
        printf("%d ", val);
        val = va_arg(args, int);
        nArgs++;
    }
    printf("\nКоличество принятых аргументов: %d\n", nArgs);
    va_end(args);
}

// Задание 6б. Модифицируйте функцию 5а с помощью макросов
//  va_start, va_arg, va_end
int sum_va(int count, ...) {
    va_list args;
    va_start(args, count);
    int sum = 0;
    for (int i = 0; i < count; i++) {
        sum += va_arg(args, int);
    }
    va_end(args);
    return sum;
}

// Задание 7. Возвращение адреса.
// Напишите функцию, которая находит минимальное значение в массиве,
// таким образом, чтобы ее вызов можно было использовать слева от знака
// равенства: *myMin(параметры) = 0;
int *myMin(int *arr, int size) {
    int *min = arr;
    for (int i = 1; i < size; i++) {
        if (arr[i] < *min) min = &arr[i];
    }
    return min;
}
